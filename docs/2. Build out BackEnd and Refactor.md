# Extend the BackEnd Web API and add Data Transfer Objects

In this session, you'll create Data Transfer Objects (DTOs) to transmit and receive data in a neutral format. This level of abstraction is useful to prevent client applications requiring dependencies on the underlying Entity Framework model. You'll implement the DTOs in a shared library that can be easily incorporated into a client application. You'll add further models to represent conference attendees, sessions, and tracks, and you'll add controllers to handle them. These controllers will include additional operations that support tasks such as bulk import of conference data. You'll generate the corresponding tables in the database, and then test the application using the Swagger API.

> **Note:** You can either continue with your own project, or use the code in the [Session 1 save point folder](../save-points/1-Create-API-and-EF-Model/ConferencePlanner).

## Create the shared library for DTOs

You'll create the shared library as a new project in the ConferencePlanner solution. You can continue with your solution from the previous exercise, or copy the code from the [Session 1 Savepoint folder](../save-points/1-Create-API-and-EF-Model).

**If you're using Visual Studio, perform the following steps:**

1. In the Solution Explorer window, right-click the **ConferencePlanner** solution, point to **Add**, and then click  **New Project**.

    ![The context menu for the **ConferencePlanner** solution. The user is adding a new project to the solution](images/2-add-new-project.png)

2. In the **Add a new project** dialog box, scroll down, and select the **Class Library (.NET Standard)** project template. Make sure that you select the C# template rather than Visual Basic, and then click **Next**.

    ![The **Add a new project** dialog box. The user has selected the **Class Library (.NET Standard)** template](images/2-create-class-library.png)

3. In the **Configure your new project** dialog box, name the project **ConferenceDTO**, and then click **Create**.

    ![The **Configure your new project** dialog box. The user has named the project **ConferenceDTO**](images/2-configure-project.png)

4. In Solution Explorer, delete the generated **Class1.cs** file from the new project.

    ![The **Solution Explorer** window. The **Class1.cs** file is highlighted](images/2-class1.png)

5. In the **BackEnd** project, right-click the **Dependencies** folder, and then click **Add Reference**.

    ![The **Solution Explorer** window showing the context menu for the **Dependencies** folder in the **BackEnd** project. The user has selected **Add Reference ...**](images/2-add-reference.png)

6. In the **Reference Manager - BackEnd** dialog box, expand the **Projects** tab, select the **ConferenceDTO** project, and then click **OK**.

    ![The **Reference Manager** dialog box. The user has selected the **ConferenceDTO** project](images/2-reference-dto.png)

**If you're using the .NET Core CLI, perform the following steps:**

1. In a command prompt window, move to the **ConferencePlanner** folder for your solution.

2. Run the following command to create a .NET Standard shared library project named **ConferenceDTO**:

   ```console
   dotnet new classlib -o ConferenceDTO -f netstandard2.0
   ```

3. Move to the **ConferenceDTO** project folder and delete the **Class1.cs** file.

4. Move to the **BackEnd** project folder under the **ConferencePlanner** solution folder.

5. Run the command shown below to add a reference to the **ConferenceDTO** project to the BackEnd project.

   ```console
   dotnet add reference ../ConferenceDTO
   ```

6. Return to the **ConferencePlanner** folder, and then run the following command to add the **ConferenceDTO** project to the solution:

   ```console
   dotnet sln add ConferenceDTO/ConferenceDTO.csproj
   ```

## Refactor the Speaker model as a DTO

1. Copy the **Speaker.cs** file from the **Models** folder in the **BackEnd** project into the root folder of the **ConferenceDTO** project.

    - **If you're using Visual Studio 2019:**

        1. In the **Solution Explorer** window, right-click the **Speaker.cs** file in the **Models** folder in the **BackEnd** project, and then click **Copy**.

            ![The context menu for the **Speaker.cs** file in the **Solution Explorer** window. The user has selected the **Copy** command](images/2-copy-file.png)

        2. Right-click the **ConferenceDTO** project, and then click **Paste**.

            ![The context menu for the **ConferenceDTO** project in the **Solution Explorer** window. The user has selected the **Paste** command](images/2-paste-file.png)

    - **If you're using the .NET Core CLI:**

        - Use an operating system command such as `COPY` (Windows Command Prompt) or `cp` (Linux) to copy the **Speaker.cs** file.

2. Edit the **Speaker.cs** file in the **ConferenceDTO** project and change the namespace to **ConferenceDTO**, as shown below.

    ```csharp
    using System;
    ...

    namespace ConferenceDTO
    {
        public class Speaker
        {
            public int Id { get; set; }
            ...
        }
    }
    ```

   > **Note:**  The data annotations references should be broken at this point because the **ConferenceDTO** project doesn't contain the NuGet appropriate package.

3. Add a reference to the NuGet package `System.ComponentModel.Annotations` version `4.7.0`:

    - **If you're using Visual Studio 2019:**

        1. In Solution Explorer, right-click the **ConferenceDTO** project, and then click **Manage NuGet Packages**.
        2. In the **NuGet Package Manager: ConferenceDTO** window, click the **Browse** tab.
        3. In the search box, type **System.ComponentModel.Annotations**, set the **Version** to **Latest stable 4.7.0**, and then click **Install**.
        4. If the **Preview Changes** dialog box appears, click **OK**.
        5. In the **License Acceptance** dialog box, click **I Accept**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **ConferenceDTO** folder.
        2. Run the following command:

            ```console
            dotnet add package System.ComponentModel.Annotations --version 4.7.0
            ```

4. In the **BackEnd** project, edit the **Speaker.cs** file in the **Models** folder, remove the properties from the **Speaker** class, and instead mark the class as a descendant of the **Speaker** class in the **ConferenceDTO** project, as shown below:

   ```csharp
   public class Speaker : ConferenceDTO.Speaker
   {
   }
   ```

5. Rebuild and run the application:

    - **If you're using Visual Studio 2019:**

        - Press **F5** to start the application in debug mode. When the application runs, a browser window should appear, open at the URL **https://localhost:*port*/api/speakers**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **ConferencePlanner** solution folder.
        2. Execute the following command to start the application:

            ```console
            dotnet run --project BackEnd
            ```

        3. Open a web browser window and move to the URL **https://localhost:*port*/api/speakers**. If the **This site is not secure** page appears, click **Details**, and then click **Go on to the webpage**.

6. Verify that the details of the speaker **Tyrion Lannister** are displayed. You added this speaker in the previous session.

    ![A web browser window showing the details of the speaker](images/2-web-speakers.png)

    > **Note:** If the speaker data is missing, you can add it again. Go to the URL **https://localhost:*port*/swagger**, and use the Swagger page to recreate the speaker, following the instructions described at the end of session 1.

7. Close the web browser and terminate the application.

## Add the remaining models to the ConferenceDTO project

In this task, you'll add DTOs that represent conference attendees, sessions, and tracks to the **ConferenceDTO** project.

1. Add a class file named **Attendee.cs** to the **ConferenceDTO** project:

    - **If you're using Visual Studio 2019:**

        1. In Solution Explorer, right-click the **ConferenceDTO** project, point to **Add**, and then click **Class**.
        2. In the **Add New Item - ConferenceDTO** dialog box, select the **Class** template, in the **Name** box, type **Attendee.cs**, and then click **Add**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **ConferenceDTO** project folder.
        2. Create a new file named **Attendee.cs** using an editor of your choice.

2. Add the following code to the **Attendee.cs** file. This class records the details of a conference attendee:

    ```csharp
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;

    namespace ConferenceDTO
    {
        public class Attendee
        {
            public int Id { get; set; }

            [Required]
            [StringLength(200)]
            public virtual string FirstName { get; set; }

            [Required]
            [StringLength(200)]
            public virtual string LastName { get; set; }

            [Required]
            [StringLength(200)]
            public string UserName { get; set; }

            [StringLength(256)]
            public virtual string EmailAddress { get; set; }
        }
    }
    ```

3. Add a class file named **Track.cs** to the **ConferenceDTO** project. Add the code shown below to this file. A conference can be divided into several tracks. Each track contains sessions that follow a particular theme.

    ```csharp
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;

    namespace ConferenceDTO
    {
        public class Track
        {
            public int Id { get; set; }

            [Required]
            [StringLength(200)]
            public string Name { get; set; }
        }
    }
    ```

4. Add a class file named **Session.cs** to the **ConferenceDTO** project, with the following code. This class models a conference session, including the title of the session, a brief description of the session,  the start time, end time, and length of the session, and the conference track to which the session belongs:

    ```csharp
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;

    namespace ConferenceDTO
    {
        public class Session
        {
            public int Id { get; set; }

            [Required]
            [StringLength(200)]
            public string Title { get; set; }

            [StringLength(4000)]
            public virtual string Abstract { get; set; }

            public virtual DateTimeOffset? StartTime { get; set; }

            public virtual DateTimeOffset? EndTime { get; set; }

            public TimeSpan Duration => EndTime?.Subtract(StartTime ?? EndTime ?? DateTimeOffset.MinValue) ?? TimeSpan.Zero;

            public int? TrackId { get; set; }
        }
    }
    ```

5. Rebuild the solution, and correct any compiler errors:

    - **If you're using Visual Studio 2019:**

        - On the **Build** menu, click **Rebuild Solution**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **ConferencePlanner** solution folder.
        2. Run the following command:

            ```console
            dotnet build
            ```

## Create derived models in the BackEnd project

In this task, you'll create some additional model classes in the **BackEnd** project, to support attendees and sessions. Rather than create the Entity Framework models directly from the DTO types in the **ConferenceDTO** project, you'll create some composite classes, such as **SessionSpeaker**. These classes will align more closely to the requirements of the front-end application. You'll build the front-end application in the next session.

1. Rename the **Models** folder in the **BackEnd** project as **Data**. This new name reflects the fact that the folder will no longer contain just models.

    - **If you're using Visual Studio 2019:**

        - In Solution Explorer, in the **BackEnd** project, right-click the **Models** folder, click **Rename**, and change the name of the folder to **Data**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **BackEnd** project folder.
        2. Rename the **Models** folder to **Data**.

2. Open the **Speaker.cs** file in the **Data** folder, and change the namespace from **BackEnd.Models** to **BackEnd.Data**.

3. Open the **ApplicationDbContext.cs** file in the **Data** folder, and change the namespace from **BackEnd.Models** to **BackEnd.Data**.

4. Edit the **SpeakersController.cs** file in the **Controllers** folder, and change the directive `using BackEnd.Models` to `using BackEnd.Data`.

5. Edit the **Startup.cs** file in the root folder of the **BackEnd** project, and change the directive `using BackEnd.Models` to `using BackEnd.Data`.

6. Add a class file named **Session.cs** to the **Data** folder. Add the code shown below to this file. The **Session** class stores information about the speakers and attendees for a conference session:

    ```csharp
    using System.Collections.Generic;

    namespace BackEnd.Data
    {
        public class Session : ConferenceDTO.Session
        {
            public virtual ICollection<SessionSpeaker> SessionSpeakers { get; set; }

            public virtual ICollection<SessionAttendee> SessionAttendees { get; set; }

            public Track Track { get; set; }
        }
    }
    ```

7. Add a class file named  **Track.cs** to the **Data** folder, with the following code. The **Track** class records which sessions belong to each conference track:

   ```csharp
   using System.Collections.Generic;

   namespace BackEnd.Data
   {
       public class Track : ConferenceDTO.Track
       {
           public virtual ICollection<Session> Sessions { get; set; }
       }
   }
   ```

8. Add a class file named **SessionSpeaker.cs** to the **Data** folder, with the code shown below. The **SessionSpeaker** class records which speakers present the individual sessions:

    ```csharp
    namespace BackEnd.Data
    {
        public class SessionSpeaker
        {
            public int SessionId { get; set; }

            public Session Session { get; set; }

            public int SpeakerId { get; set; }

            public Speaker Speaker { get; set; }
        }
    }
    ```

9. Add a class file named **Attendee.cs** to the **Data** folder, with the following code. This class stores information about the conference attendees. It's based on the **Attendee** DTO class:

    ```csharp
    using System.Collections.Generic;

    namespace BackEnd.Data
    {
        public class Attendee : ConferenceDTO.Attendee
        {
            public virtual ICollection<SessionAttendee> SessionsAttendees { get; set; }
        }
    }
    ```

10. Add a class file named **SessionAttendee.cs** to the **Data** folder, with the code shown below. This class tracks which sessions have been, or might be, attended by a conference delegate:

    ```csharp
    namespace BackEnd.Data
    {
        public class SessionAttendee
        {
            public int SessionId { get; set; }

            public Session Session { get; set;}

            public int AttendeeId { get; set; }

            public Attendee Attendee { get; set; }
        }
    }
    ```

11. Modify the **Speaker** class in the **Speaker.cs** file in the **Data** folder. Remove any unnecessary `using` directives, and add a reference to the **SessionSpeaker** composite class, as shown below:

    ```csharp
    using System.Collections.Generic;

    namespace BackEnd.Data
    {
        public class Speaker : ConferenceDTO.Speaker
        {
            public virtual ICollection<SessionSpeaker> SessionSpeakers { get; set; } 
                = new List<SessionSpeaker>();
        }
    }
    ```

## Update the database context class

In this task, you'll update the **ApplicationDbContext** with details of the new models.

1. Edit the **ApplicationDbContext.cs** file in the **Data** folder.  Modify the code in this file as shown below:

    ```csharp
    using Microsoft.EntityFrameworkCore;

    namespace BackEnd.Data
    {
        public class ApplicationDbContext : DbContext
        {
            public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
                : base(options)
            {

            }

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Entity<Attendee>()
                .HasIndex(a => a.UserName)
                .IsUnique();

                // Many-to-many: Session <-> Attendee
                modelBuilder.Entity<SessionAttendee>()
                    .HasKey(ca => new { ca.SessionId, ca.AttendeeId });

                // Many-to-many: Speaker <-> Session
                modelBuilder.Entity<SessionSpeaker>()
                    .HasKey(ss => new { ss.SessionId, ss.SpeakerId });
            }

            public DbSet<Session> Sessions { get; set; }

            public DbSet<Track> Tracks { get; set; }

            public DbSet<Speaker> Speakers { get; set; }

            public DbSet<Attendee> Attendees { get; set; }
        }
    }
    ```

2. Remove all files in the **Migrations** folder for the **BackEnd** project. These files were generated by using the database migration tool, based on the previous version of the model.

3. Rebuild the **ConferencePlanner** solution, and ensure that it builds without any errors or warnings.

## Add a new database migration

In this task, you'll update the database with the new models you added in the previous tasks.

**If you're using Visual Studio, perform the following steps:**

1. On the **Tools** menu, point to **NuGet Package Manager**, and then click **Package Manager Console**.

2. In the **Package Manager Console** window, set the **Default project** to **BackEnd**.

    ![The **Package Manager Console** window. The user has set the default project to **BackEnd**](images/2-set-default-project.png)

3. Run the following commands in the **Package Manager Console** window, at the **PM>** prompt:

    ```console
    Add-Migration Refactor
    Drop-Database
    Update-Database
    ```

    When prompted to drop the existing database, press **Y**, and then press Enter.

**If you're using the .NET Core CLI, perform the following steps:**

1. In a command prompt window, move to the **BackEnd** project folder.

2. Install the Entity Framework database migration tools if you haven't already done so, as follows:

    1. Run the following command:

        ```console
        dotnet tool install -g dotnet-ef --version 3.1.2
        ```

    2. Close the command prompt window, and start a new command prompt session.

    3. Return to the **BackEnd** project folder.

3. Run the following commands:

    ```console
    dotnet ef migrations add Refactor
    dotnet ef database drop
    dotnet ef database update
    ```

    When prompted to drop the existing database, press **y**.

## Verify the updated database model

1. Rebuild and run the **ConferencePlanner** application.

2. If you're using Visual Studio 2019, a web browser window will open automatically. If you're using the .NET Core CLI, open a new web browser window.

3. In the web browser, go to the URL **https://localhost:*port*/swagger**. You should see the new models appear under the **Schemas** section of the Swagger page.

    ![The **Swagger** UI showing the additional schemas.](images/2-schemas.png)

4. Expand each schema in turn, and compare the fields in every one to the properties in the corresponding types in the **BackEnd** web application.

5. Close the browser window, and terminate the application.

## Update the Speakers API controller

In this task, you'll update the **Speakers** controller to retrieve speaker information using the composite types you defined in the earlier task.

1. Open the **SpeakersControllers.cs** file in the **Controllers** folder in the **BackEnd** project.

2. Modify the **GetSpeakers()** method as shown below. The data returned by this method now includes **SessionSpeaker** information, and **Session** information for the **SessionSpeaker** property:

    ```csharp
    // GET: api/Speakers
    [HttpGet]
    public async Task<ActionResult<IEnumerable<Speaker>>> GetSpeakers()
    {
        var speakers = await _context.Speakers.AsNoTracking()
                               .Include(s => s.SessionSpeakers)
                                   .ThenInclude(ss => ss.Session)
                               .ToListAsync();
        return speakers;
    }
    ```

   While this code will work, it returns an object based directly on the model class. This approach can introduce a tight coupling between the model and client applications. A better practice is to return an output model class that maps to an independent representation that doesn't depend on the Entity Framework model. This is the approach you'll implement in the next steps.

3. Create a new class file named **SpeakerResponse.cs** in the **ConferenceDTO** project, with the following code. The **SpeakerResponse** class is an enhanced version of the **Speaker** class that includes the list of sessions the speaker presents:

    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Text;

    namespace ConferenceDTO
    {
        public class SpeakerResponse : Speaker
        {
            public ICollection<Session> Sessions { get; set; } = new List<Session>();
        }
    }
    ```

4. Add a new folder, named **Infrastructure**, to the **BackEnd** project.

5. Add a class file named **EntityExtensions.cs** to the **Infrastructure** folder, using the following code. **MapSpeakerReponse** is an extension method of the **Speaker** class that generates a **SpeakerResponse** object from a **Speaker** object:

    ```csharp
    using System.Linq;

    namespace BackEnd.Data
    {
        public static class EntityExtensions
        {
            public static ConferenceDTO.SpeakerResponse MapSpeakerResponse(this Speaker speaker) =>
                new ConferenceDTO.SpeakerResponse
                {
                    Id = speaker.Id,
                    Name = speaker.Name,
                    Bio = speaker.Bio,
                    WebSite = speaker.WebSite,
                    Sessions = speaker.SessionSpeakers?
                        .Select(ss =>
                            new ConferenceDTO.Session
                            {
                                Id = ss.SessionId,
                                Title = ss.Session.Title
                            })
                        .ToList()
                };
        }
    }
    ```

6. Update the **GetSpeakers** method of the **SpeakersController** so that it returns a **SpeakerResponse** object, as follows:

    ```csharp
    [HttpGet]
    public async Task<ActionResult<List<ConferenceDTO.SpeakerResponse>>> GetSpeakers()
    {
        var speakers = await _context.Speakers.AsNoTracking()
                                        .Include(s => s.SessionSpeakers)
                                            .ThenInclude(ss => ss.Session)
                                        .Select(s => s.MapSpeakerResponse())
                                        .ToListAsync();
        return speakers;
    }
    ```

7. Update the **GetSpeaker** method to use the **SpeakerResponse** model:

    ```csharp
    [HttpGet("{id}")]
    public async Task<ActionResult<ConferenceDTO.SpeakerResponse>> GetSpeaker(int id)
    {
        var speaker = await _context.Speakers.AsNoTracking()
                                        .Include(s => s.SessionSpeakers)
                                            .ThenInclude(ss => ss.Session)
                                        .SingleOrDefaultAsync(s => s.Id == id);
        if (speaker == null)
        {
            return NotFound();
        }
        return speaker.MapSpeakerResponse();
    }
    ```

8. Remove the actions **PutSpeaker**, **PostSpeaker**, and **DeleteSpeaker**, from the **SpeakersController**. The **Speakers** controller will only be used for querying speaker information. Also remove the private **SpeakerExists** method.

## Add an API Controller and DTO for managing attendees

1. Create a new class file, named **AttendeeResponse.cs**, in the **ConferenceDTO** project. Add the code shown below to this file:

    ```csharp
    using System.Collections.Generic;

    namespace ConferenceDTO
    {
        public class AttendeeResponse : Attendee
        {
            public ICollection<Session> Sessions { get; set; } = new List<Session>();
        }
    }
    ```

    You'll use the **AttendeeResponse** class to return information about conference attendees, including the sessions they've attended.

2. In the **BackEnd** project, edit the **EntityExtension.cs** file in the **Infrastructure** folder, and add the **MapAttendeeResponse** method shown below to the **EntityExtensions** class, after the **MapSpeakerResponse** method:

    ```csharp
    public static class EntityExtensions
    {
        public static ConferenceDTO.SessionResponse MapSessionResponse(this Session session) =>
        ...

        public static ConferenceDTO.AttendeeResponse MapAttendeeResponse(this Attendee attendee) =>
            new ConferenceDTO.AttendeeResponse
            {
                Id = attendee.Id,
                FirstName = attendee.FirstName,
                LastName = attendee.LastName,
                UserName = attendee.UserName,
                Sessions = attendee.SessionsAttendees?
                    .Select(sa =>
                        new ConferenceDTO.Session
                        {
                            Id = sa.SessionId,
                            Title = sa.Session.Title,
                            StartTime = sa.Session.StartTime,
                            EndTime = sa.Session.EndTime
                        })
                    .ToList()
            };
    }
    ```

3. Add a new controller, named **AttendeesController**, to the **BackEnd** project:

    - **If you're using Visual Studio 2019:**

        1. On the **Build** menu, click **Rebuild Solution**.
        2. In the **Solution Explorer** window, in the **BackEnd** project, right-click the **Controllers** folder, point to **Add**, and then click **Controller**.
        3. In the **Add New Scaffolded Item** dialog box, select **API Controller with actions, using Entity Framework**, and then click **Add**.
        4. In the **Add API Controller with actions, using Entity Framework** dialog box, in the **Model class** list, click **Attendee (BackEnd.Data)**.
        5. In the **Data context class** list, click **ApplicationDbContext (BackEnd.Data)**, and then click **Add**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **BackEnd** project folder.
        2. Install the ASP.NET Code Generator tools, if you haven't already done so, as follows:

            1. Run the following command:

                ```console
                dotnet tool install -g dotnet-aspnet-codegenerator
                ```

            2. Close the command prompt window, and open a new one; the tools aren't available until you start a new command session.

            3. Return to the **BackEnd** project folder.

        3. Execute the following command to create the **Attendees** controller:

            ```console
            dotnet aspnet-codegenerator controller -api -name AttendeesController -m BackEnd.Data.Attendee -dc BackEnd.Data.ApplicationDbContext -outDir Controllers
            ```

4. In the **Controllers** folder, open the **AttendeesController.cs** file.

5. Add the following `using` directive to the list at the start of the file:

    ```csharp
    using ConferenceDTO;
    ```

6. Delete the **GetAttendees** method, including the **HttpGet** attribute.

7. Replace the **GetAttendee** method with the code shown below. Note that the method now returns a value based on the **AttendeeResponse** type, and the parameter is a string rather than an integer.

    ```csharp
    [HttpGet("{username}")]
    public async Task<ActionResult<AttendeeResponse>> GetAttendee(string username)
    {
        var attendee = await _context.Attendees.Include(a => a.SessionsAttendees)
                                               .ThenInclude(sa => sa.Session)
                                               .SingleOrDefaultAsync(a => a.UserName == username);

        if (attendee == null)
        {
            return NotFound();
        }

        var result = attendee.MapAttendeeResponse();

        return result;
    }
    ```

8. Delete the **PutAttendee** method, including the **HttpPut** attribute.

9. Replace the **PostAttendee** method with the following code. This method creates a new attendee and returns the details of the new attendee as an **AttendeeResponse** object.

    ```csharp
    [HttpPost]
    [ProducesResponseType(StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<ActionResult<AttendeeResponse>> PostAttendee(ConferenceDTO.Attendee input)
    {
        // Check if the attendee already exists
        var existingAttendee = await _context.Attendees
            .Where(a => a.UserName == input.UserName)
            .FirstOrDefaultAsync();

        if (existingAttendee != null)
        {
            return Conflict(input);
        }

        var attendee = new Data.Attendee
        {
            FirstName = input.FirstName,
            LastName = input.LastName,
            UserName = input.UserName,
            EmailAddress = input.EmailAddress
        };

        _context.Attendees.Add(attendee);
        await _context.SaveChangesAsync();

        var result = attendee.MapAttendeeResponse();
        return CreatedAtAction(nameof(GetAttendee), new { username = result.UserName }, result);
    }
    ```

10. Add the **AddSession** method shown below to the controller. This method records the attendee as having attended the specified session:

    ```csharp
    [HttpPost("{username}/session/{sessionId}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesDefaultResponseType]
    public async Task<ActionResult<AttendeeResponse>> AddSession(string username, int sessionId)
    {
        var attendee = await _context.Attendees.Include(a => a.SessionsAttendees)
                                               .ThenInclude(sa => sa.Session)
                                               .SingleOrDefaultAsync(a => a.UserName == username);

        if (attendee == null)
        {
            return NotFound();
        }

        var session = await _context.Sessions.FindAsync(sessionId);

        if (session == null)
        {
            return BadRequest();
        }

        attendee.SessionsAttendees.Add(new SessionAttendee
        {
            AttendeeId = attendee.Id,
            SessionId = sessionId
        });

        await _context.SaveChangesAsync();

        var result = attendee.MapAttendeeResponse();

        return result;
    }
    ```

11. Remove the **DeleteAttendee** method, and replace it with the **RemoveSession** method shown below. This method removes the specified session from the attendance record for the attendee:

    ```csharp
    [HttpDelete("{username}/session/{sessionId}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesDefaultResponseType]
    public async Task<IActionResult> RemoveSession(string username, int sessionId)
    {
        var attendee = await _context.Attendees.Include(a => a.SessionsAttendees)
                                               .SingleOrDefaultAsync(a => a.UserName == username);

        if (attendee == null)
        {
            return NotFound();
        }

        var session = await _context.Sessions.FindAsync(sessionId);

        if (session == null)
        {
            return BadRequest();
        }

        var sessionAttendee = attendee.SessionsAttendees.FirstOrDefault(sa => sa.SessionId == sessionId);
        attendee.SessionsAttendees.Remove(sessionAttendee);

        await _context.SaveChangesAsync();

        return NoContent();
    }
    ```

12. Delete the **AttendeeExists** method.

13. Rebuild the solution, and correct any errors.

## Add an API Controller and DTO for managing sessions

1. Return to the **ConferenceDTO** project, and create a new class file named **SessionResponse.cs**. Add the code shown below to this file. The **SessionResponse** class contains the details for a session. It includes information about the track for a session, and the speakers presenting it:

    ```csharp
    using System.Collections.Generic;

    namespace ConferenceDTO
    {
        public class SessionResponse : Session
        {
            public Track Track { get; set; }

            public List<Speaker> Speakers { get; set; } = new List<Speaker>();
        }
    }
    ```

2. In the **BackEnd** project, edit the **EntityExtension** class in the **Infrastructure** folder, and add the **MapSessionResponse** method shown below, after the **MapAttendeeResponse** method:

    ```csharp
    public static class EntityExtensions
    {
        public static ConferenceDTO.SpeakerResponse MapSpeakerResponse(this Speaker speaker) =>
        ...

        public static ConferenceDTO.AttendeeResponse MapAttendeeResponse(this Attendee attendee) =>
        ...

        public static ConferenceDTO.SessionResponse MapSessionResponse(this Session session) =>
            new ConferenceDTO.SessionResponse
            {
                Id = session.Id,
                Title = session.Title,
                StartTime = session.StartTime,
                EndTime = session.EndTime,
                Speakers = session.SessionSpeakers?
                                  .Select(ss => new ConferenceDTO.Speaker
                                  {
                                      Id = ss.SpeakerId,
                                      Name = ss.Speaker.Name
                                  })
                                   .ToList(),
                TrackId = session.TrackId,
                Track = new ConferenceDTO.Track
                {
                    Id = session?.TrackId ?? 0,
                    Name = session.Track?.Name
                },
                Abstract = session.Abstract
            };
    }
    ```

3. Add a new controller, named **SessionsController**, to the **Controllers** folder in the **BackEnd** project:

    - **If you're using Visual Studio 2019:**

        1. Rebuild the solution.
        2. Select the **API Controller with actions, using Entity Framework** template.
        3. Set the **Model class** to **Session (BackEnd.Data)**.
        4. Set the **Data context class** to **ApplicationDbContext (BackEnd.Data)**.
        5. Set the name to **SessionsController**.

    - **If you're using the .NET Core CLI:**

        1. Move to the **BackEnd** project folder.
        2. Run the following command:

            ```console
            dotnet aspnet-codegenerator controller -api -name SessionsController -m BackEnd.Data.Session -dc BackEnd.Data.ApplicationDbContext -outDir Controllers
            ```

4. In the **Controllers** folder, open the **SessionsController.cs** file.

5. Add the directive `using ConferenceDTO;` to the list at the start of the file.

6. Modify the **GetSessions** method as shown below. Note that the method returns a list of **SessionResponse** objects rather than **Session** objects:

    ```csharp
    [HttpGet]
    public async Task<ActionResult<List<SessionResponse>>> GetSessions()
    {
        var sessions = await _context.Sessions.AsNoTracking()
                                              .Include(s => s.Track)
                                              .Include(s => s.SessionSpeakers)
                                                  .ThenInclude(ss => ss.Speaker)
                                              .Select(m => m.MapSessionResponse())
                                              .ToListAsync();
        return sessions;
    }
    ```

7. Change the **GetSession** method to retrieve and return a **SessionResponse** object, as follows:

    ```csharp
    [HttpGet("{id}")]
    public async Task<ActionResult<SessionResponse>> Get(int id)
    {
        var session = await _context.Sessions.AsNoTracking()
                                             .Include(s => s.Track)
                                             .Include(s => s.SessionSpeakers)
                                                 .ThenInclude(ss => ss.Speaker)
                                             .SingleOrDefaultAsync(s => s.Id == id);

        if (session == null)
        {
            return NotFound();
        }

        return session.MapSessionResponse();
    }
    ```

8. Replace the **PutSession** method with the code shown below. This method takes a DTO containing session information, and uses it to modify an existing session with the same ID in the database:

    ```csharp
    [HttpPut("{id}")]
    public async Task<IActionResult> PutSession(int id, ConferenceDTO.Session input)
    {
        var session = await _context.Sessions.FindAsync(id);

        if (session == null)
        {
            return NotFound();
        }

        session.Id = input.Id;
        session.Title = input.Title;
        session.Abstract = input.Abstract;
        session.StartTime = input.StartTime;
        session.EndTime = input.EndTime;
        session.TrackId = input.TrackId;

        await _context.SaveChangesAsync();

        return NoContent();
    }
    ```

9. Replace the **PostSession** method with the following code. This method creates a new session using the information in the DTO provided as the parameter, and stores the session data in the database:

    ```csharp
    [HttpPost]
    public async Task<ActionResult<SessionResponse>> PostSession(ConferenceDTO.Session input)
    {
        var session = new Data.Session
        {
            Title = input.Title,
            StartTime = input.StartTime,
            EndTime = input.EndTime,
            Abstract = input.Abstract,
            TrackId = input.TrackId
        };

        _context.Sessions.Add(session);
        await _context.SaveChangesAsync();

        var result = session.MapSessionResponse();

        return CreatedAtAction(nameof(Get), new { id = result.Id }, result);
    }
    ```

10. Modify the **DeleteSession** method using the code shown below:

    ```csharp
    [HttpDelete("{id}")]
    public async Task<ActionResult<SessionResponse>> DeleteSession(int id)
    {
        var session = await _context.Sessions.FindAsync(id);

        if (session == null)
        {
            return NotFound();
        }

        _context.Sessions.Remove(session);
        await _context.SaveChangesAsync();

        return session.MapSessionResponse();
    }
    ```

11. Remove the **SessionExists** method.

12. Rebuild the solution, and correct any errors.

## Add support for uploading conference data

In this task, you'll add a method to the **SessionsController** class that enables the user to import the details of conference sessions from a JSON file. The import process uses a class named **SessionizeLoader** that parses the contents of the JSON file and extracts the details of sessions, tracks, and speakers from this file. You don't need to understand how the **SessionizeLoader** works, although the source code is available in the [**SessionizeLoader.cs**](../save-points/2-BackEnd-completed/SessionizeLoader.cs) file in the save point folder for this session.

1. In the **BackEnd** project, in the **Data** folder, create a class file named **DataLoader.cs**, with the following code:

    ```csharp
    using System.IO;
    using System.Threading.Tasks;

    namespace BackEnd.Data
    {
        public abstract class DataLoader
        {
            public abstract Task LoadDataAsync(Stream fileStream, ApplicationDbContext db);
        }
    }
    ```

2. In the **BackEnd** project, in the **Data** folder, create another class file, named **SessionizeLoader.cs**.

3. Copy the contents of the [**SessionizeLoader.cs**](../save-points/2-BackEnd-completed/SessionizeLoader.cs) class file in the save point folder into your **SessionizeLoader.cs** file. Note that the **SessionizeLoader** class extends the **DataLoader** abstract class.

4. Edit the **SessionsController.cs** file in the **Controllers** folder, and add the **Upload** method shown below to the controller. This method takes the name of a JSON file containing conference data, and uses the data loader to read the contents and populate the database.

    ```csharp
    [HttpPost("upload")]
    [Consumes("multipart/form-data")]
    public async Task<IActionResult> Upload(IFormFile file)
    {
        var loader = new SessionizeLoader();
         using (var stream = file.OpenReadStream())
        {
            await loader.LoadDataAsync(stream, _context);
        }

        await _context.SaveChangesAsync();

        return Ok();
    }
    ```

## Test the web API and upload conference data

1. Copy the sample data file, **NDC_London_2020.json** from the [sample data folder](/src/BackEnd/Data/Import) to a convenient place on your computer.

2. Rebuild and run the **ConferencePlanner** application.

3. If you're using Visual Studio 2019, a web browser window will open automatically. If you're using the .NET Core CLI, open a new web browser window.

4. In the web browser, go to the URL **https://localhost:*port*/swagger**. You should see operations available through the **Attendees**, **Sessions**, and **Speakers** controllers.

    ![The **Swagger** UI showing the new controllers and operations.](images/2-controllers.png)

5. In the **Sessions** section, click the **POST** button for the **api/Sessions/upload** operation, and then click **Try it out**.

6. In the **Parameters** section, at the **file** prompt, click **Browse**.

7. In the **Open** dialog box, browse to the folder containing your clone of the GitHub repository, move to the folder **src/BackEnd/Data/Import** in the repository, select the file **NDC_London_2020.json**, and then click **Open**.

8. Back in the web browser, click **Execute**, and wait for the data to be uploaded. Verify that the upload is successful (the server response code should be 200).

    ![The **Swagger** UI. The user has executed the session upload operation.](images/2-upload-sessions.png)

9. In the web browser, scroll up and click the **GET** button for the **api/Sessions** operation. Click **Try it out**, and then click **Execute**.

10. Verify that the response body contains details of the conference sessions, in JSON format:

    ![The **Swagger** UI showing the details of sessions.](images/2-sessions.png)

11. Scroll down and click the **GET** button for the **api/Speakers** operation. Click **Try it out**, and then click **Execute**. This time, the response body should contain details about the conference speakers and the sessions they're presenting, again in JSON format.

12. Close the browser window, and terminate the application.

> **Note:** You can find the completed code for the exercises in this session in the [Session 2 save point folder](../save-points/2-BackEnd-completed/)

**Next**: [Session #3 - Create the FrontEnd web application](3.%20Add%20front-end%2C%20render%20agenda%2C%20set%20up%20front-end%20models.md) | **Previous**: [Session #1 - Create the BackEnd Web API](1.%20Create%20BackEnd%20API%20project.md)
